# Система памяти Zep

## Что такое Zep?

Zep — это специализированная долговременная система памяти для LLM-приложений, которая обеспечивает эффективное хранение, извлечение и управление историей взаимодействий с искусственным интеллектом. В контексте n8n Супер-агента, Zep играет критическую роль, позволяя агенту сохранять контекст диалогов, "запоминать" предпочтения пользователя и использовать предыдущие взаимодействия для формирования более точных и релевантных ответов.

### Почему Zep?

Обычный ИИ-ассистент "забывает" весь контекст взаимодействия после завершения текущего диалога. Zep решает эту проблему, предоставляя:

- **Долговременную память**: хранение истории взаимодействий для длительного использования
- **Векторные представления**: возможность семантического поиска по прошлым взаимодействиям
- **Контекстную осведомленность**: агент "помнит" предыдущие разговоры и может ссылаться на них
- **Персонализацию**: адаптация поведения на основе прошлых взаимодействий с конкретным пользователем

## Архитектура и компоненты Zep

### Основные компоненты Zep:

1. **Memory Store**: хранилище исторических данных (в нашем случае использует PostgreSQL)
2. **Chunker**: компонент для разделения контента на оптимальные фрагменты
3. **Embeddings**: создание векторных представлений текста
4. **Search**: поиск по релевантной истории

### Интеграция в n8n:

В n8n Супер-агенте Zep интегрируется через два основных компонента:

- **Zep Memory Node** (`n8n-nodes-langchain.memoryzep`): используется для доступа к истории чата
- **Zep Vector Store Node** (`n8n-nodes-langchain.vectorstorezep`): предоставляет функциональность RAG (Retrieval-Augmented Generation)

## Настройка и конфигурация Zep

### Конфигурация в `zep-config.yaml`

В проекте настройка Zep определена в файле `zep-config.yaml`:

```yaml
server:
  host: 0.0.0.0
  port: 8000
  cors:
    allowed_origins:
      - "*"
    allow_credentials: true

datastore:
  type: postgres
  postgres:
    dsn: "postgres://zep:zep@postgres-zep:5432/zep?sslmode=disable"

nlp:
  tokenizer: local
  embedder:
    service: "http://embeddings-service:8080"
    type: "huggingface"
    dimensions: 384  # для all-MiniLM-L6-v2
  chunker:
    strategy: recursive
    parameters:
      chunk_size: 256            # Оптимизированный размер
      chunk_overlap: 25          # Небольшое перекрытие для связности
      separators:
        - "\n\n"                 # Параграфы
        - "\n"                   # Строки
        - ". "                   # Предложения
        - "! "                   # Восклицания
        - "? "                   # Вопросы
        - ":"                    # Перечисления
        - ";"                    # Перечисления
        - ","                    # Списки
        - " "                    # Слова (последний вариант)

memory:
  message_window: 15             # Увеличенное окно сообщений
  auto_summarize: true           # Включаем автоматическое резюмирование
  auto_summarize_threshold: 12   # Порог для автоматического резюмирования
```

### Ключевые параметры для оптимизации:

- **chunk_size**: размер фрагментов текста (оптимальное значение зависит от используемой модели LLM)
- **chunk_overlap**: перекрытие между фрагментами для сохранения контекста
- **message_window**: количество сообщений, включаемых в контекст
- **auto_summarize_threshold**: количество сообщений, после которого выполняется автоматическое резюмирование

### Переменные окружения в `docker-compose.yml`:

```yaml
zep:
  image: ghcr.io/getzep/zep:latest
  restart: always
  ports:
    - "8000:8000"
  environment:
    - ZEP_MEMORY_STORE_POSTGRES_URI=postgres://zep:zep@postgres-zep:5432/zep
    - ZEP_LOG_LEVEL=info
    - OPENAI_API_KEY=${OPENAI_API_KEY}
  volumes:
    - zep_data:/data
    - ./zep-config.yaml:/app/config.yaml
    - ./logs/zep:/var/log/zep
```

## Использование Zep в n8n Супер-агенте

### Типы памяти

В n8n Супер-агенте используются два типа памяти Zep:

1. **Общая память** (Zep All): 
   - Хранит контекст для всего диалога или пользователя
   - Используется, когда несколько узлов Zep применяют одинаковый Session ID

2. **Специфическая память** (Zep Specifics): 
   - Хранит контекст для конкретных категорий задач
   - Использует уникальные Session ID для разных категорий

### Управление контекстом через Session ID

Ключевым параметром для управления памятью является Session ID:

```
# Для общей памяти во всех узлах используется одинаковый ID
session_id = "user_123"

# Для специфической памяти используются уникальные ID для разных категорий
session_id_search = "user_123_search"
session_id_calendar = "user_123_calendar"
```

В n8n это реализуется через динамическое определение Session ID:

```
{{ $('Chat').item.json.memory }}
```

### Примеры использования в workflows

#### Пример для веб-поиска:

```json
{
  "prompt": "Вы выполняете веб-поиск. Используйте доступный инструмент для поиска в интернете.\n\nПредставьте каждый результат поиска со следующими деталями:\nЗаголовок: [Заголовок результата]\nОтрывок: [Отрывок результата]\nДата публикации: [Дата публикации результата]\nURL: [URL результата]",
  "memory": "search"
}
```

#### Пример для Hacker News:

```json
{
  "prompt": "Вы получаете статьи с Hacker News.",
  "memory": "hacker.news"
}
```

## Оптимизация и советы по использованию Zep

### 1. Оптимизация чанкера

Параметры чанкера (в `zep-config.yaml`) следует настраивать под конкретные модели LLM:
- Для небольших моделей: меньший `chunk_size` (128-256)
- Для более мощных моделей: больший `chunk_size` (512-1024)
- Увеличивайте `chunk_overlap` при работе со сложными или техническими текстами

### 2. Управление долговременной памятью

Для предотвращения переполнения контекста:
- Используйте `auto_summarize: true`
- Настройте `auto_summarize_threshold` в зависимости от сложности ваших диалогов
- Периодически очищайте ненужные данные из памяти

### 3. Эффективное использование специфической памяти

- Создавайте отдельные Session ID для разных доменов/функций
- Для связанных категорий задач можно использовать общую память
- Разделяйте личную/общую информацию и специализированные данные

### 4. Мониторинг использования

Для отслеживания использования памяти Zep:
- Проверяйте логи: `docker-compose logs zep`
- Мониторьте размер базы данных: `docker exec -it postgres-zep psql -U zep -c "\l+"`
- Отслеживайте производительность запросов: `docker exec -it postgres-zep psql -U zep -c "SELECT * FROM pg_stat_activity WHERE datname='zep'"`

## Устранение неполадок

### 1. Проблемы с подключением:
```bash
# Проверка состояния контейнера Zep
docker-compose ps zep

# Проверка логов
docker-compose logs zep
```

### 2. Проблемы с хранилищем:
```bash
# Проверка подключения к базе данных
docker exec -it postgres-zep psql -U zep -c "\conninfo"

# Проверка таблиц
docker exec -it postgres-zep psql -U zep -c "\dt"
```

### 3. Сброс памяти:
В случае необходимости полного сброса памяти:
```bash
# Очистка таблиц (но не структуры базы)
docker exec -it postgres-zep psql -U zep -c "TRUNCATE TABLE zep_memory, zep_memory_documents, zep_memory_summary CASCADE;"
```

## Заключение

Система памяти Zep является одним из ключевых компонентов, которые делают n8n Супер-агента по-настоящему "умным" и контекстно-осведомленным. Она позволяет агенту сохранять контекст взаимодействий, учиться на предыдущих диалогах и адаптироваться к потребностям пользователя.

Правильная настройка и использование Zep значительно повышают качество взаимодействия с агентом, делая его более естественным и полезным.
